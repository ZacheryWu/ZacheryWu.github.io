---
title: 浏览器的工作原理
date: 2020-04-18 18:49:09
tags:
---

 页面的性能好通常是指页面加载速度快，用户交互流畅。其中主要有加载速度和交互流畅这两个部分，为了能够提高页面的加载速度，使页面更加流畅我们需要去了解一些浏览器加载页面和渲染页面的原理。

从在导航栏输入url按下回车开始，主要涉及到以下几个方面：

- 导航
- 响应
- 解析
- 渲染
- 交互

## 导航

导航是一个加载一个页面的第一步，是指从输入url或者提交表单到和对应的服务器建立连接的这个过程。主要包括下面三步：

### DNS 查找

一般在互联网上给出的都是域名，需要通过DNS转化成IP之后在进行服务器的定位。

- 查询DNS时会优先查询本地的缓存，如果已经缓存该域名，那么直接返回域名对应的IP，不需要再进行下面的步骤
- 如果没有在缓存中找到，那么则需要向DNS服务器发起查询，先查询根域名服务器然后再查询顶级域名服务器，然后再查询次级域名服务器，具体细节在此不展开。最终会得到该域名对应的IP地址。

得到IP之后就可以和对应的服务器建立链接了。

### 建立TCP连接

由于http协议在传输层是基于TCP协议的，所以需要建立TCP连接。

建立TCP连接要通过“三次握手”，也就是`SYN-SYN,ACK-ACK`的过程，确保通信双方的接受和发送功能的正常，在建立TCP链接之后，如果不需要建立安全连接，那么就可以开始请求资源了，如果需要建立安全的连接，那么还需要下面的步骤。

### TLS协商

TLS是Transport Layout Security的缩写，用来在HTTP上建立安全的连接，也就是HTTPS。TLS协议的基本思路是采用公钥加密算法，也就是说客户端先向服务端发起请求获取到公钥，然后使用公钥加密加密信息，服务端收到信息之后用私钥解密。也是需要一个握手的过程，大致的流程如下：

1. 客户端向服务端索要并验证公钥
2. 双方协商生成对话密钥
3. 使用生成的对话密钥进行通信

![ssl](\images\ssl.jpg)

 经过TCP连接和TLS协商，浏览器终于可以安全的发起请求了，接下来就是网络请求的部分

## 响应

建立连接之后，浏览器会向服务器发起请求，作为一个网站，通常请求的第一个资源是html文件，服务器会把html文件和一些头信息一起返回。

### 慢启动

而由于TCP的慢启动，第一块内容通常是小于14kb的，因此这也是我们进行优化时需要注意的一个点，也就是“14kb原则”。TCP的慢启动是指TCP均衡网络传输速度的算法，慢启动然后逐渐增加发送数据的数量，直到达到网络的最大带宽。在收到初始包之后, 服务器会将下一个包的大小加倍到大约28kb。 后续的包依次是前一个包大小的二倍直到达到预定的阈值，或者遇到拥塞。

![congestioncontrol](\images\congestioncontrol.jpg)

### 拥塞

在客户端和服务端进行数据传递时，通过确认帧也就是ACK来确认包的正确接受，而网络传输的数量是有限的，当传输的数据超过传输数量的上限，就会造成包的丢失，也就是丢包。因此我们需要使用拥塞控制算法来对网络传输的数据量进行控制。



## 解析

浏览器接收到第一块信息之后就可以开始解析了，会把接收到的数据解析成DOM、CSSOM这样的浏览器能够理解的数据形式，然后再通过渲染器把DOM和CSSOM绘制成页面。

即便浏览器请求的HTML是大于14kb的，浏览器也会在第一块数据到达之后就尝试解析。这也是为什么要求在前14kb中要包含浏览器渲染的首屏的全部内容。

### 构建DOM树

浏览器开始解析收到HTML文件，大致是下面的流程

字节数据->字符串->Token->Node->DOM

这颗DOM树包含了HTML 的内容信息，也表达了不同节点对应的层级关系。

在进行解析时，如果遇到了非阻塞资源，比如一张图片，那么浏览器会请求这张图片，然后继续解析，当遇到了css资源，也可以继续解析。但是当遇到了阻塞资源，比如script标签(没有加async和defer的script标签)，那么就需要停止解析，等待script加载、执行完毕之后再继续解析。

### 预加载扫描器

浏览器对DOM的解析会占据主线程，这时预加载扫描器会对html进行扫描然后去加载优先级较高的资源。而不必等到构建DOM树解析到那个标签时，再进行加载。它将在后台运行，当HTML解析到这个资源时可能已经加载完毕了。预加载扫描器的优化减少了解析HTML的阻塞。

```html
<link rel="stylesheet" src="styles.css"/>
<script src="myscript.js" async></script>
<img src="myimage.jpg" alt="image description"/>
<script src="anotherscript.js" async></script>
```

在上面这个例子中，预加载扫描器会在浏览器解析HTML和CSS时，预加载扫描器将找到脚本和图片进行加载。为了确保脚本不会阻塞进程，建议在JavaScript的解析和执行不被顺序影响时加上async或者defer属性。

### 构建CSSOM

解析CSS的过程和HTML相同：

字节数据->字符串->Token->Node->CSSOM

在学习这块的时候，我一直有个问题，CSS既然没有和DOM结合，那么为什么CSS也会有树结构呢？

这是因为浏览器为任何一组对象计算样式时都会先从适用于该节点的最通用的规则开始（例如该节点是body的子节点，那么将先应用所有的body可继承样式），然后通过更具体的规则以递归的方式去修改样式。 只是文字的描述还是不够清楚，下面从一个例子来看一下。

```css
body { font-size: 16px }
p { font-weight: bold }
span { color: red }
p span { display: none }
img { float: right }
```

span标签内的任何置于body内的文本的font-size都为16px，并且字体颜色为红色，font-size属性从body继承到span中，不过如果某个span是在p标签下的，那么这个标签不予显示。

根据上面的分析，得到的CSSOM如下:

![cssom-tree](\images\cssom-tree.png)

需要注意，这还并不是最终展示使用的CSSOM，因为每个节点的样式都还需要结合浏览器的默认样式（也就是我们在浏览开发者工具中看到的user-agent样式），也就是我们不提供任何自定义样式时的默认样式，我们的样式只是去替换了这些样式。

### JavaScript编译

当CSS被解析并创建CSSOM时，其他资源，包括JavaScript文件正在下载（多亏了preload scanner）。JavaScript被解释、编译、解析和执行。脚本被解析为抽象语法树。一些浏览器引擎使用”Abstract Syntax Tree“并将其传递到解释器中，输出在主线程上执行的字节码。这就是所谓的JavaScript编译。



## 渲染

前面已经够构建好了DOM树和CSSOM树，这两个是完全独立的树，分别描述文档的不同信息，DOM树描述文档内容，CSSOM树描述对文档应用的样式规则。将这两者结合起来得到的渲染树，让浏览器在屏幕上渲染像素。

### 合并生成渲染树

渲染的第一步就是把DOM树和CSSOM树合并生成渲染树，渲染树包含页面上所有的可见元素的内容以及对应的样式信息。

![render-tree-construction](\images\render-tree-construction.png)

构建渲染树的过程中浏览器完成了以下工作：

1. 从根节点开始遍历DOM树的可见节点。对于某些不可见的节点，由于不会渲染输出，所以被忽略，如head标签，元标签等等。对于CSSOM中display：none的节点也不会渲染输出，被忽略。
2. 把遍历到的可见节点匹配对应的样式信息。
3. 将节点连接起来形成树结构。

渲染构造完成之后就可以开始对页面进行布局了。

### 布局 （layout）

我们已经确定了每个元素的内容和对应的样式信息，但是我们还不知道元素在页面上的位置，布局的作用就是确定每个元素的位置。

为了弄清楚每个节点的位置，浏览器从根节点开始遍历，一一确定元素在对应视口下的绝对位置，最终会输出一个个元素对应的盒模型，它会精确的描述每个元素在视口中的位置和大小，所有的测量值都会转换为绝对的像素值。

第一次确定元素的位置被成为布局，而当元素的大小或者位置发生了变化，那么就要重新计算元素的位置和大小，这个过程被成为回流。

当知道每个元素是否可见，元素的具体位置，以及元素的样式信息，就可以开始进行绘制元素了。

### 绘制（paint）

绘制是根据元素的样式信息，将元素的阴影、颜色、文本、边框等等绘制在页面上。

而为了保证页面的流畅，占据主线程的绘制(由于是单线程的)，包括计算样式，回流和绘制，必须要让浏览器在16.6ms之内完成。为了确保重绘的速度比初始绘制的速度更快，屏幕上的绘图通常被分解成数层。如果发生这种情况，则需要进行合成。

绘制可以将布局树中的元素分解为多个层。将内容提升到GPU上的层（而不是CPU上的主线程）可以提高绘制和重新绘制性能。有一些特定的属性和元素可以实例化一个层，包括<video>和<canvas>，任何CSS属性为opacity、3D转换、`will-change`的元素，还有一些其他元素。这些节点将与子节点一起绘制到它们自己的层上，除非子节点由于上述一个（或多个）原因需要自己的层。

### 合成（compositing）

当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。

### 优化

当页面加载资源时可能会发生回流。比如在html中包含有图片，回流会触发重绘和重新合成。而如果我们定义了图片的大小，当资源请求回来之后，就只需要重新绘制对应的层，而不是从回流开始。

当页面元素比较多时，回流是很耗时的，而且回流发生时也必然会发生重绘，所以我们应该尽量的避免回流的出现。

## 交互

主线程绘制完页面，似乎一切已经结束了，然而并不是，当页面中有JS，并且JS中的操作都在onload事件中时，主线程会去解析js，这时页面依旧是无法操作的，直到js解析完成，主线程才会空闲下来，页面才可以进行点击、滚动等操作。

TTI(time to interactive)是指从第一个请求的DNS解析开始，到页面可以交互所用的时间，而可交互是指在页面首次绘制完成之后，页面可以在50ms内对用户操作做出反应的交互。如果主线程被占用，将导致TTI大大延长，极大的影响用户的体验，因此要尽可能地避免占用主线程。

![visa_network](\images\visa_network.png)

如上图中的情况，解析JS完全占用了主线程1.5s左右的时间，在这段时间内，用户的点击、滚动等操作都不会被相应。(那么这些操作会保存下来，等主线程空闲之后继续执行吗？还是直接舍弃掉呢？)

## 总结

经过这次的学习，对于浏览器渲染页面的过程有了了解，虽然没有深入到更深的层次，但是对于性能优化的理解，也是很有帮助的。







## 参考资料

[渲染页面：浏览器的工作原理](https://developer.mozilla.org/zh-CN/docs/Web/Performance/浏览器渲染页面的工作原理)

[SSL/TLS协议运行机制的概述](https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)

[构建对象模型](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=zh-cn)

[渲染树构建、布局及绘制](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction#tldr)

[浏览器渲染原理-前端面试之道]()