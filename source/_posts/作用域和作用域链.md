---
title: 作用域到作用域链
date: 2020-03-04 15:57:00
tags:
---

 作用域和作用域链比原型略微复杂了一些，主要牵扯到以下这几个概念：

1. 执行上下文和执行上下文栈
2. 作用域链（Scope chain）
3. 变量对象（VO）

上面的概念是按照自顶向下的顺序的，从最宏观角度开始分析。

### 执行上下文和执行上下文栈

__执行上下文__是JavaScript代码执行时环境的抽象，所有的JavaScript代码都是在执行上下文中执行的。

每个执行上下文都有三个重要的属性：

1. 变量对象(VO)
2. 作用域链(Scope chain)
3. this，这个由于和作用域链没有太大关系，在此不讨论。

一共有三种执行上下文类型：

- 全局执行上下文，默认的、最基础的执行上下文，任何不在函数中的执行上下文都在全局执行上下文中。
- 函数执行上下文，每一个函数被调用时，都会为该函数生成一个新的函数执行上下文。而执行上下文栈通常就是由函数执行上下文组成的。
- eval执行上下文，这个不常使用，在此不讨论。

负责管理执行上下文的，就是__执行上下文栈__。

在程序的开始，会创建全局的执行上下文，并压入执行上下文栈中，在执行过程中，如果遇到函数，就生成函数的执行上下文，并压入执行上下文栈中，在函数执行完毕后从栈中弹出。当所有的代码执行完毕，全局执行上下文从栈中弹出，整个程序运行完毕。

### 作用域链(Scope chain)

作用域链是执行上下文的重要属性。我们都知道，在查找变量的时候，都会现在当前上下文的变量对象中寻找，如果找不到就会从父级的执行上下文变量对象中查找，直到全局上下文中的变量对象，也就是全局对象。这个由多个执行上下文的变量对象组成的链表就是作用域链。

下面讨论下作用域链是怎么构建的。

1. 首先要介绍一个概念，__词法作用域__

   词法作用域又叫静态作用域，和动态作用域相对。词法作用域是指，在函数声明的时候，他的作用域就已经确定了。而动态作用域则是在代码执行的过程中生成的。

2. 为了保存函数声明时创建的作用域，函数的内部有一个属性__[[scope]]__ , 在函数声明时，会保存所有的父级变量对象到内。

   举个例子：

   ```js
   function foo() {
       function bar() {
           
       }
   }
   ```

   在创建foo函数的时候就会生成foo.[[scope]]

   ```js
   foo.[[scope]] = [globalContext.VO]
   ```

   而在执行foo时，又会创建bar，生成bar.[[scope]]

   ```js
   bar.[[scope]] = [
       fooContext.VO,
       globalContext.VO
   ]
   ```

3. 在执行到函数时，函数被激活，进入函数上下文，创建活动对象(AO，活动对象其实就是变量对象，只是因为被激活了，所以叫法不同)，活动对象会被添加到作用域链的最前端，这样在查找作用域链时就可以最先查找到当前上下文的变量对象了。

   还以上面的代码为例，这时的作用域链可以表示为：

   ```js
   bar.[[scope]] = [
       AO,
       fooContext.VO,
       golbalContext.VO
   ]
   ```

这时整个作用域链就已经构建完成了，已经能够沿着作用域链进行变量的查找。接下来了解一下作用域链中保存的VO/AO。

### 变量对象(VO)

变量对象是作用域链的底层变量，存储了上下文中定义的变量和函数。

在全局执行上下文中和函数执行上下文中的变量对象不太相同，所以分开来聊聊。

1. 全局上下文中

   其实全局上下文中的变量对象我们很熟悉，就是全局变量！在浏览器环境中就是window这个变量。

   全局变量作为作用域链的最顶级，它上面绑定了很多的函数和属性，如Math对象、settimeout方法等等，这也是我们可以在任意上下文中访问到这些函数和对象的原因。

2. 函数执行上下文中

   在函数执行上下文中，用活动对象(activation Object)来表示变量对象。

   其实VO和AO是一种东西，只是变量对象是引擎底层实现的，不能在JavaScript环境中访问，只有进行到一个函数执行上下文中，这个执行上下文的变量对象才会被激活，激活后也就是活动对象了，而只有活动对象上的各种属性才可以进行访问。在函数执行结束后，活动对象又会变为变量对象。

   活动对象是在进入函数执行上下文时被创建的，通过函数的arguments属性初始化。

#### 执行过程

执行过程被分为两个阶段进行处理：

- 进入执行上下文
- 代码执行

1. 进入执行上下文

   变量对象包括：

   1. 函数的所有形参(函数执行上下文中)
      - 创建由名称和值组成的变量对象的属性
      - 没有实参的情况下，创建由名称和undefined组成的变量对象的属性
   2. 函数声明
      - 由名称和函数组成的变量对象的属性
      - 如果这个属性已经存在，那么用函数覆盖掉
   3. 变量声明
      - 由名称和对应值组成的变量对象的属性
      - 如果变量名称和已经声明的形参或者函数相同，那么这个变量声明废弃掉

   举个例子：

   ```js
   function fn(a) {
       function b() {};
       var c = 10;
       var a = 20;
       var d = function() {},
   }
   fn(1)
   ```

   在进入执行上下文后，AO为：

   ```js
   AO = {
       arguments: {
           0: 1,
           length: 1
       },
       a: 1,
       b: reference to function b(){},
       c: undefined,
       d: undefined,
   }
   ```

   上面还有一个变量a的声明，但是由于变量对象中已经有这个名称的属性了，所以会被忽略掉。

2. 代码执行

   在代码执行的阶段，会按照顺序执行代码，并且同时修改AO。

   上面的例子执行结束之后AO为：

   ```js
   AO = {
       arguments: {
           0: 1,
           length: 1,
       },
       a: 20,
       b: reference to function b() {},
      	c: 10,
       d: reference to function() {},
   }
   ```

总结一下上面的过程：

1. 全局上下文的变量对象是全局对象
2. 活动对象初始化时只有arguments这个属性
3. 在执行代码前，会把形参、函数声明、变量对象添加到活动对象中
4. 在代码执行过程中会不断地更新活动对象

所有的概念就介绍完了，下面拿个例子来看一下完整的代码执行过程：

### 举例说明

```js
var test = '我能吃下玻璃而不伤身体';
function foo(test) {
	var obj = {};
	return obj;
}
foo();
```

1. 创建foo函数，在创建的同时把作用域链保存到foo的内部属性[[scope]]：

   ```js
   foo.[[scope]] = [globalContext.VO]
   ```

   这时其实就是将函数创建时的作用域保存了起来，也就是词法作用域。

2. 到`foo()`这行语句的时候，创建函数执行上下文，并且压入ECS中

   ```js
   ECS = [
       fooContext,
       globalContext
   ]
   ```

3. 在执行函数之前，先做准备工作，首先把函数的[[scope]]复制过来放到活动对象的作用域链中：

   ```js
   FooContext = {
       Scope: foo.[[scope]]
   }
   ```

4. 然后使用arguments创建活动对象，并加入形参、变量、函数

   ```js
   FooContext = {
       AO: {
           arguments: {
               0: '我能吃下玻璃而不伤身体',
               length: 1
           },
           test: '我能吃下玻璃而不伤身体',
           obj: undefined,
       },
       Scope: foo.[[scope]]
   }
   ```

5. 准备工作的最后把AO压入作用域链的最前端

   ```js
   FooContext = {
       AO: {
           arguments: {
               0: '我能吃下玻璃而不伤身体',
               length: 1
           },
           test: '我能吃下玻璃而不伤身体',
           obj: undefined,
       },
       Scope: [AO, globalContext.AO]
   }
   ```

6. 准备工作已完成，开始执行函数，函数执行完成之后AO变为：

   ```js
   FooContext = {
       AO: {
           arguments: {
               0: '我能吃下玻璃而不伤身体',
               length: 1
           },
           test: '我能吃下玻璃而不伤身体',
           obj: reference to obj,
       },
       Scope: [AO, globalContext.AO]
   }
   ```

7. 最后从Scope中查找到obj的值，然后返回，函数执行结束，将函数从ECS中弹出，这时ECS变为：

   ```js
   ECS = [globalContext]
   ```



## 总结

其实作用域链的生成并不复杂，只要捋顺了还是很好理解的，从ECS到执行上下文，再到变量对象和作用域链，环环相扣。其中最复杂的地方就是变量对象，但也不过几条规则就能够讲清楚。



### 参考资料：

[JavaScript深入之作用域链](https://github.com/mqyqingfeng/Blog/issues/6)

[理解JavaScript中的执行上下文](https://juejin.im/post/5ba32171f265da0ab719a6d7)

[十分钟理解JavaScript执行上下文](https://juejin.im/post/5ba32171f265da0ab719a6d7)

JavaScript高级程序设计(第三版)





