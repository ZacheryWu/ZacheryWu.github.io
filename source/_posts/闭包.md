---
title: 闭包
date: 2020-03-16 20:35:31
tags:
---

	函数与对其状态即词法环境的引用共同构成闭包。也就是说，闭包可以让你从内部函数访问外部函数的作用域。在JavaScript中，函数在每次创建时生成闭包。 ----《MDN 闭包》

上面是MDN上关于闭包的定义，可以看出，按照这个说法，所有的JavaScript函数都是闭包，然而和我们平时面试时所说的闭包却并不一样。在我们平时说的闭包是指：`即使创建函数的上下文已经销毁，但在函数中依然能够访问到创建函数时的上下文`。所以其实我们平时说的闭包是理论上闭包的一种特殊情况。

## 原始的面试题

下面就总结一下平时所说的，实践中的闭包。之前已经总结过作用域的相关知识，而要理解闭包只需要这些知识就够了，并不需要引入新的知识。先从一道经典的题目来分析一下闭包：

```js
let data = [];
for(var i = 0; i < 3; i++) {
	data[i] = function() {
		console.log(i);
    }
}
data[0]();//3
data[1]();//3
data[2]();//3
```

代码执行的步骤为：

1. 创建全局上下文globalContext，并压入ECS中

   ```js
   globalContext = {
       VO: {
           data: undefined,
           i: undefined,
       },
       [scope]: [globalContext.VO],
       this: window
   }
   ECS: [globalContext]
   ```

2. 开始执行全局环境下的代码，VO中的data和i相继被赋值，在执行`data[0]()`之前，VO为：

   ```js
   globalContext.VO = {
       data: Array,
       i: 3
   }
   ```

3. 在执行`data[0]()`之前创建它的执行上下文：

   ```js
   data0Context = {
       AO: {
           arguments: {length: 0},
       },
       [scope]:[AO, globalContext.VO],
       this: undefined,
   }
   ```

4. 开始执行`data[0]()` ，在执行时顺着作用域链查找变量i，在AO中没有找到，所以继续向上找，在globalContext.VO中找到了i，这时的i值为3 。所以console.log打印出的为3 。

5. 后面的`data[1]()` 和`data[2]()` 与之前相同，在此不再赘述。这样一套分析下来，为什么输出是3，就很明确了。

## 此类问题的解决

为了解决拿不到想要的值得问题，我们采用了这种方式：

```js
var data = [];
for(var i = 0; i < 3; i++) {
    data[i] = (function(i) {
        return function () {
            console.log(i)
        }
    })(i)
}
data[0]();//0
data[1]();//1
data[2]();//2
```

其实只在外面加了一层匿名函数，那么这层匿名函数起到了什么效果呢。再来分析一下：

1. 创建全局上下文globalContext，并压入ECS中

   ```js
   globalContext = {
       VO: {
           data: undefined,
           i: undefined,
       },
       [scope]: [globalContext.VO],
       this: window
   }
   ECS: [globalContext]
   ```

2. 开始执行全局环境下的代码，VO中的data和i相继被赋值，在执行`data[0]()`之前，VO为：

   ```js
   globalContext.VO = {
       data: Array,
       i: 3
   }
   ```

3. 在执行`data[0]()`之前创建它的执行上下文：

   ```js
   data0Context = {
       AO: {
           arguments: {length: 0},
       },
       [scope]:[AO, 匿名函数.VO, globalContext.VO],
       this: undefined,
   }
   ```

   注意，就是在这里出现了不同，data[0]的作用域中多了一级匿名函数。

4. 开始执行`data[0]()` ，在执行时顺着作用域链查找变量i，在AO中没有找到，所以继续向上找，在匿名函数.VO查找，这时匿名函数的VO为：

   ```js
   匿名函数.VO = {
       arguments: {
   		i: 0,
           length: 1,
       }
   }
   ```

   所以在匿名函数.VO中找到了i，此时的i为0 ，所以`data[0]()`输出为0，即使外面globalContext.VO中的i依旧为3。

5. 另外两个和`data[0]()`类似，在此不再赘述。

所以所谓的通过闭包来解决此类问题就是在其中再加一层函数作用域用来缓存当时的变量i。

## 使用let解决此问题

使用let关键字可以比闭包更加优雅的解决这类问题：

```js
var data = [];
for(let i = 0; i < 3; i++) {
    data[i] = function () {
        console.log(i);
    }
}
data[0]();//0
data[1]();//1
data[2]();//2	
```

上面代码在经过babel转义之后为：

```js
var data = [];

var _loop = function _loop(i) {
data[i] = function () {
		console.log(i);
	};
};

for (var i = 0; i < 3; i++) {
_loop(i);
}
data[0]();//0
data[1]();//1
data[2]();//2	
```

其实和使用闭包的方式是差不多的，都是在加了一个函数作用域用来存储变量i的值，只是这个作用域的位置有所不同。至于let具体在js中是怎么实现的，在此不详细分析(本来以为是语法糖，然而找了一圈，并没有let是语法糖的说法)。

## 总结

其实平时我们说的闭包就是JavaScript的作用域在使用时产生的一种特殊现象，如果理解了底层JavaScript的作用域链，闭包其实并不算是问题😀。


### 参考资料
[JavaScript深入之闭包](https://github.com/mqyqingfeng/Blog/issues/9)
[JavaScript深入之执行上下文](https://github.com/mqyqingfeng/Blog/issues/8)
[闭包 MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)
[闭包 Wikipedia](https://en.wikipedia.org/wiki/Closure_(computer_programming))
闭包 Javascript高级程序设计