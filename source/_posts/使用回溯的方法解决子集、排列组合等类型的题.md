---
title: 使用回溯的方法解决子集、排列组合等类型的题
date: 2019-07-08 22:12:29
tags:
---
# 使用回溯的方法解决子集、排列组合等类型的题

在刷leetcode的时候，发现一个答案把这类题目放到了一起，并且都采用了同一种方法解题，感觉很有意思，就自己参照该答案的方法，用js做了一遍，也是很有收获，对于递归和dfs都有了更深的理解。

## 1. 子集问题（leetcode第78题）

**Question**： Given a set of **distinct** integers, *nums*, return all possible subsets (the power set).

**Note:** The solution set must not contain duplicate subsets.

（简单来说就是给一组不包含重复数字的数组，列出这个数组的所有子集）

先放代码：

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
	let ret = [];
	recursive(ret, [], nums, 0);
	return ret;
};

/**
 * @param {number[][]} ret 
 * @param {number[]} tempArr 
 * @param {number[]} nums 
 * @param {number} start 
 */
var recursive = function(ret, tempArr, nums, start) {
	ret.push(tempArr.slice());

	for(let i = start; i < nums.length; i++) {
		tempArr.push(nums[i]);
		recursive(ret, tempArr, nums, i+1);
		tempArr.pop();
	}
}
console.log(subsets([1,2,3]))//[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]
```

这是这类题最基本的情况，只要深度优先遍历就可以得到答案，不需要做任何其他的处理。

以输入数组[1,2,3]为例过一下代码流程：

1. 进入recursive，ret 中push进去[]
2. 进入循环，tempArr中push进去1，然后进入下一层recursive
   1. ret中push进去[1]
   2. 进入循环，tempArr中push进去2，变为[1,2],然后进入下一层recursive
      1. ret中push进去[1,2]
      2. 进入循环，tempArr中push进去[3],变为[1,2,3]，然后进入下一层recursive
         1. ret中push进去[1,2,3]
         2. 进入循环，循环结束，回到上一层recursive
      3. tempArr中pop出来一个3，变为[1,2]，循环结束，回到上一层recursive
   3. tempArr中pop出来一个2，变为[1],继续循环
   4. tempArr中push进来一个3，变为[1,3],进入下一层recursive
      1. ret中push进去[1,3]
      2. 进入循环，循环结束，返回上一层recursive
   5. tempArr中pop出来一个3，变为[1]，循环结束返回上一层
3. 继续循环，tempArr中push进来一个[2]，变为[2]，进入下一层recursive
   1. ret中push进去[2]
   2. 进入循环，tempArr中push进来一个3，变为[2,3]进入下一层recursive
      1. ret中push进去[2,3]
      2. 进入循环，循环结束，回到上一层recursive
   3. tempArr中pop出来一个[3]，变为[2]，循环结束，返回上一层
4. tempArr中pop出来一个[2],变为[],继续循环
5. tempArr中push进来一个[3],变为[3],进入下一层recursive
   1. ret中push进去一个[3]
   2. 进入循环，循环结束，返回上一层recursive
6. tempArr中pop出来一个3，变为[]，循环结束回到函数subsets
7. 返回ret

以上就是整个递归的过程。本质上是使用栈实现了一个dfs。只要理解了整个思想写起来是不难的，但是在写代码的时候需要__注意__，在把tempArr放到ret中的时候，要把复制之后的tempArr放进去，而不是tempArr的本体，因为tempArr作为一个栈，在程序运行过程中是不断地变化的，如果直接把tempArr的引用丢进去的话，最后的ret将得到一个[[],[],[],[],[],[],[],[]]这样的空数组。



## 2. 子集问题进阶（leetcode 第90题）

**Question:**Given a collection of integers that might contain duplicates, **nums**, return all possible subsets (the power set).

**Note:** The solution set must not contain duplicate subsets.

(和上面的很像，区别在于给的数组中会有重复的数字出现)

代码：

```js
/**
 * 在求nums的子集时，[1,2]和[1,2]是一样的，所以并不能用标记的方式来确保结果的不重复
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsetsWithDup = function(nums) {
	nums.sort((a,b) => a-b);
	let ret = [];
	recursive(ret, [], nums, 0);
	return ret;
};

/**
 * @param {number[][]} ret 
 * @param {number[]} tempArr 
 * @param {number[]} nums 
 * @param {number} start 
 */
var recursive = function(ret, tempArr, nums, start) {
	ret.push(tempArr.slice());

	for(let i = start; i < nums.length; i++) {
		if(i > start && nums[i] === nums[i-1]) continue;
		tempArr.push(nums[i]);
		recursive(ret, tempArr, nums, i+1);
		tempArr.pop();
	}
}

console.log(subsetsWithDup([1,2,2]))
```

和上面那道题一样，都是求子集，所以还是采用深度优先遍历的方法，但是由于传入的数组有重复的存在，并且在结果中判定[1,2]（由1和第一个2组成）和[1,2]（由1和第二个2组成）是一样的，所以在深度优先遍历的时候要过滤掉这些重复的情况。因为[1,2]（由1和第一个2组成）和[1,2]（由1和第二个2组成）是一样的，所以不能通过标记这个数字是否被使用过的方法来过滤重复。

可以想到，我们要通过判断是不是第一个[1,2]来确定是否过滤，可以发现对于排过序的数组，tempArr为第二个[1,2]的时候，nums[i]===num[i-1] ，可以根据这个条件来进行过滤。但是需要注意的是，在[1,2,2]中也会有读到第二个2的情况，所以我们不能把所有的非第一次出现的数字都过滤掉。我们可以通过i>start来判断，这是不是这个回溯的第一层循环，如果不是第一层循环，并且nums[i]===nums[i-1]就说明，这是第二个[1,2]而不是[1,2,2]的情况。因此，通过(i > start && nums[i] === nums[i-1])这个判断条件就能够刚好成功的过滤掉所有重复的情况。



## 3. 排列组合问题（leetcode 46题）

**Question:**Given a collection of **distinct** integers, return all possible permutations.

代码：

``` js
/**
 * 在这种列出所有组合的题中，由于每个item都只能使用一次，正是标志位使用的好时候
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
	let used = nums.map(() => false),
		ret = [];
	recursive(ret, nums, [], used);
	return ret;
};

var recursive = function(ret, nums, tempArr, used) {
	if(tempArr.length === nums.length) {
		ret.push(tempArr.slice());
	} else {
		for(let i = 0 ; i < nums.length; i++) {
			if(used[i]) continue;
			used[i] = true;
			tempArr.push(nums[i]);
			recursive(ret, nums, tempArr, used);
			used[i] = false;
			tempArr.pop();
		}
	}
}

console.log(permute([1,2,3]));
```

这种排列组合的问题，由于每一项都只能用一次，所以可以用标记项的方法来进行过滤，所以我单独创建了一个数组用来保存每一项的状态，表示该项是否已经使用过。递归结束条件和之前的递归到底就结束也不太一样了，但还是很简单，只要tempArr中已经包含了所有的数字，就说明这一个排列组合已经完成了，那么这个递归就结束了，把这个递归结果存起来，然后进行回溯，去进行其他排列组合的遍历。



## 4. 排列组合问题进阶(leetcode 47题)

__Question:__ Given a collection of numbers that might contain duplicates, return all possible unique permutations.

代码：

``` js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permuteUnique = function(nums) {
	nums.sort((a,b) => a-b);
	let used = nums.map(() => false),
		ret = [];
	recursive(ret, nums, [], used);
	return ret;
};

var recursive = function(ret, nums, tempArr, used) {
	if(tempArr.length === nums.length) {
		ret.push(tempArr.slice());
	} else {
		for(let i = 0; i < nums.length; i++) {
			if(used[i] || (nums[i] === nums[i-1] && !used[i-1])) continue;
			used[i] = true;
			tempArr.push(nums[i]);
			recursive(ret, nums, tempArr, used);
			used[i] = false;
			tempArr.pop();
		}
	}
}

console.log(permuteUnique([1,1,2]));
```

同样是排列组合的问题，所以还是创建一个数组来标记某一项是否用过。但是和上一道排列组合有所不同的是，在给的数组中有重复数字的存在，并且在每个排列中相同数字交换位置视为同一种排列，因此也需要进行过滤。

一开始打算采用和子集问题进阶(leetcode90题)一样的方法进行解决，却发现由于在排列问题中，每次循环都是从0开始的，因此不能够使用i和start的比较来判断是否是某个递归的第一层循环，此方法行不通。但是这次我们多了一个used数组，所以可以这样判断，在这一项的数字和前一项的数字相同时（数组已排序），

- 如果前一项已经使用过，那么这个排列是第一次出现（因为我们的遍历是从前到后的），我们继续这个遍历
- 如果前一项并没有使用过，那么说明这一个排列(1,1,2)是之前排列(1,1,2)的这两个相同数字的交换的结果（两个1交换了顺序），这时跳过这次遍历。



## 5. 组合求和问题（leetcode 39题）

__Question:__ Given a **set** of candidate numbers (`candidates`) **(without duplicates)** and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sums to `target`.

The **same** repeated number may be chosen from `candidates` unlimited number of times.

**Note:**

- All numbers (including `target`) will be positive integers.
- The solution set must not contain duplicate combinations.

代码：

``` js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
	let ret = [];
	recursive(ret, candidates, [], target, 0);
	return ret;
};

/**
 * 
 * @param {number[][]} ret 
 * @param {number[]} candidates 
 * @param {number[]} tmepArr 
 * @param {number} remain 
 */
var recursive = function(ret, candidates, tmepArr, remain, start) {
	if(remain < 0) return
	else if(remain === 0) {
		ret.push(tmepArr.slice());
	} else {
		for(let i = start; i < candidates.length; i++) {
			tmepArr.push(candidates[i]);
			recursive(ret, candidates, tmepArr, remain-candidates[i], i);
			tmepArr.pop();
		}
	}
}


// console.log(combinationSum([2,3,6,7], 7));
console.log(combinationSum([2,3,5], 8));
```

从候选数组中找出所有的和为target的子集，其实是之前的子集问题(leetcode 78题 subset)的进阶，对找出的子集再进行一次筛选而已，但是如果先找到所有的子集再进行筛选，这样的时间复杂度无疑是很高的，所以在遍历的同时进行筛选，就能少遍历一些不可能的分支，从而提高效率。

我采取的方法是这样的，在遍历的同时，对于已经遍历到的元素

- 如果和已经大于了目标数，那么说明这个分支再往下走也不可能满足条件了，因为给出的候选数都是正数，因此这次递归结束，回到上一层递归，继续遍历。
- 如果和等于目标数，那么说明这个分支已经满足了要求，把这个分支中的数放到结果数组中，结束这次递归，回到上一层递归，继续遍历。
- 如果和小于目标数，那么说明这次递归还要继续，因此继续递归，直到满足条件。

还有一点需要注意的是，循环是从上层递归的那个元素开始的，因为在这个问题中，每一项都可以使用多次。但是也不能从零开始，因为如果从零开始，那么[2,3,3]和[3,2,3]以及[3,3,2]都会出现在结果中。



## 6.组合求和问题进阶(leetcode 40题)

**Question: **Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sums to `target`.

Each number in `candidates` may only be used **once** in the combination.

**Note:**

- All numbers (including `target`) will be positive integers.
- The solution set must not contain duplicate combinations.

代码：

``` js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum2 = function(candidates, target) {
	candidates = candidates.sort((a,b) => a-b);
	let ret = [];
	recursive(ret, candidates, [], target, 0);
	return ret;
};

var recursive = function(ret, candidates, tempArr, remain, start) {
	if(remain < 0) return 
	else if(remain === 0) ret.push(tempArr.slice())
	else {
		for(let i = start; i < candidates.length; i++) {
			if(candidates[i] === candidates[i-1] && i > start) continue;
			tempArr.push(candidates[i]);
			recursive(ret, candidates, tempArr, remain-candidates[i], i+1);
			tempArr.pop();
		}
	}
}

console.log(combinationSum2([2,5,2,1,2], 5));
```

这个问题是上面的进阶，现在给出的数组中有些数字是重复的，并且每一项都只能使用一次。看到这个条件是不是有点眼熟，对，就是上面提到的第二个问题（子集问题进阶，leetcode90），相当于是第五个问题和第二个问题结合起来了。用到了组合求和问题（leetcode39）的递归结束部分，以及子集进阶问题（leetcode90）的筛选部分。思路和上面的问题是完全一样的，在此不再赘述。



## 7. 回文分区问题(leetcode 131)

**Question: ** Given a string *s*, partition *s* such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of *s*.

``` js
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function(s) {
	let ret = [];
	recursive(ret, s, [], 0);
	return ret;
};

/**
 * 
 * @param {string[]} ret 
 * @param {string} s 
 * @param {string[]} tempArr 
 * @param {number} start 
 */
var recursive = function(ret, s, tempArr, start) {
	if(start === s.length) ret.push(tempArr.slice());
	else {
		for(let i = start; i < s.length; i++) {
			if(isPalindrome(s, start, i)) {
				tempArr.push(s.slice(start, i+1));
				recursive(ret, s, tempArr, i+1);
				tempArr.pop();
			}
		}
	}
}

/**
 * @param {string} s 
 * @param {number} start 
 * @param {number} end 
 */
var isPalindrome = function(s, start, end) {
	while(start < end) {
		if(s.charAt(start++) !== s.charAt(end--)) return false
	}
	return true;
}

console.log(partition("aab"));
/*[
  ["aa","b"],
  ["a","a","b"]
]*/
```

这个问题乍一看似乎不能通过深度优先遍历的方法来解决，其实仔细想一想还是第一个问题的变种，都是找到给出的数组子集，只不过这个问题给出的不是数组，而是字符串罢了。既然想通了这点，还套着原来的步骤来就可以了，只不过在判断某个子集是否是满足条件的时有一点小麻烦。

我采用的方法是判断这个start标记位是否已经到达了这个字符串的最后，如果到了最后那就说明这个子集tempArr中已经包含了这个字符串中的所有字符，并且在把子字符串加到tempArr中时，已经判断过了这个字符串是不是回文，所以能保证所有加到tempArr中的字符串都是回文的。因此，当tempArr中已经包含了这个字符串中的所有字符时，就说明tempArr已经是满足条件的一种排列。 



## 总结

这七道题做下来，可以感觉得到，后面六题其实都是第一道题的变种罢了。其中变化的是给的数组的形式，包括正整数，重复的正整数，字符串。另一个变化就是要求输出的数组的规则，子集，排列组合，和为目标数，回文串等等。根据这些变化，求修改递归结束的条件，以及在循环中的筛选条件，再稍微修改一些循环的细节，就能够得到满足条件的输出。

因此，对于这类题目，近乎可以用套模板的方式解决，只要根据题目情况想清楚递归的结束条件，以及筛选的方法就可以了。当然，有时候递归的结束条件和筛选方法并不容易想到，所以，还是多做题吧。