---
title: 继承
date: 2020-03-27 11:11:36
tags:
---

 JavaScript中的继承有多种实现方式，各有优缺点

### 原型链

```js
function Cat() {
	this.sayHi = function() {
		console.log('miao~');
	},
	this.habit = ['sleep', 'mouse']
}
function YellowCat() {
	this.color = 'yellow';
}
let catProto = new Cat();
YellowCat.prototype = catProto;
let xiaohua = new YellowCat();
let anotherCat = new YellowCat();
xiaohua.habit.push('milk'); //["sleep", "mouse", "milk"]
console.log(anotherCat.habit); //
console.log(xiaohua.color) //yellow
xiaohua.sayHi(); //miao~
```

上面的代码通过原型链的方式实现了继承，然而，这种通过修改构造函数的prototype属性，来实现的原型链还存在一些问题：

1. 原型上的属性会被共享，这也是在构造函数中定义属性而不是在原型对象中定义属性的原因。就拿上面的代码来说，xiaohua在habit中添加了milk，却也改变了anotherCat的habit属性。所以一般我们只在原型上定义方法，而不定义属性。
2. 在创建子类型的实例时，不能向超类型的构造函数中传递参数。具体来说，就是在创建YellowCat的实例时无法向Cat传参，如果要修改原型，那么将会导致所有的实例能够获取到的属性都被修改。

### 借用构造函数

```js
function Cat(color) {
	this.sayHi = function() {
		console.log('miao~');
	},
	this.color = color
	this.habit = ['sleep', 'mouse']
}
function YellowCat() {
	Cat.call(this, 'color');
}
let xiaohua = new YellowCat();
let anotherCat = new YellowCat();
xiaohua.habit.push('milk');
console.log(anotherCat.habit)//["sleep", "mouse"]
```

使用构造函数解决了原型链方法的两个问题，可以看到habit属性在两个属性中是独立，互不影响，不被共享，而且可以向超类实例中传递参数。

但是这种方式也有一些缺点，那就是无法对方法复用，也就是说每创建一个实例都会重新构建一个属性方法就比如上面的sayHi。而在原型链实现的继承中是没有这个问题的，所以我们可以把这两种方式结合起来，就是下面的组合继承。

### 组合继承

```js
function Cat(color) {
	this.color = color
	this.habit = ['sleep', 'mouse']
}
Cat.prototype.sayHi = function() {
	console.log('miao~');
}
function YellowCat() {
	Cat.call(this, 'color');
}

YellowCat.prototype = new Cat();
YellowCat.prototype.eat = function() {
	console.log('be fat')
}
YellowCat.prototype.constructor = YellowCat;
let xiaohua = new YellowCat();
let anotherCat = new YellowCat();
xiaohua.habit.push('milk');
console.log(anotherCat.habit)
console.log(xiaohua.sayHi === anotherCat.sayHi)//true
```

优点：解决了构造函数继承和原型链继承的问题，成为JavaScript中最常用的继承方式

缺点：会调用两次超类的构造方法，并且超类实例中的属性肯定会被重写。

### 原型式继承

原型式继承的核心是这个方法：

```js
function object(o) {
	function F() {};
	F.prototype = o;
	return new F();
}
```

通过创建一个内部的函数F，并且设置他的原型为传进来的参数o，返回一个以F为构造函数生成的对象，实现了对对象o的复制。其实和原型链式继承很像，只不过这里继承的是一个对象，而不是一个构造函数的原型。

```js
var person = {
	name: 'Rajsh',
	friends: ['Sheldon', 'Leonard', 'Howard']
}
var anotherPerson = object(person);
anotherPerson.name = 'Bernadette';
anotherPerson.friends.push('Penny');

var yetAnoterhPerson = object(person);
yetAnoterhPerson.name = 'Amy';
console.log(yetAnoterhPerson.friends); //["Sheldon", "Leonard", "Howard", "Penny"]
console.log(anotherPerson.name)//Bernadette
```

这种方式创建的对象也是共享person上的属性的，但是也各自拥有自己的name属性。其实相当于创建了person的两个副本。

### 寄生式继承

寄生式继承又把原型式继承封装了一下，类似于一个工厂

```js
function createObject(o) {
	var clone = object(o);
	clone.sayHi = function() {
		console.log("hello, I'm "+ this.name)
	}
	return clone;
}
```

在object方法的基础上，又给对象添加了公共方法，可以这样使用：

```js
var person = {
	name: 'Rajsh',
	friends: ['Sheldon', 'Leonard', 'Howard']
}
var anotherPerson = createObject(person);
anotherPerson.name = 'Bernadette';
anotherPerson.sayHi(); //hello, I'm Bernadette
```

这样生成的对象不仅继承了person上的属性，还拥有自己的方法sayHi。

### 组合寄生式继承

终于到这里了，利用前面了解到的寄生式继承，可以解决组合继承的那个缺点，首先创建一个方法：

```js
function inheritPrototype(subType, superType) {
	var prototype = superType.prototype;
	prototype.constructor = subType;
	subType.prototype = prototype;
}
```

使用这个方法可以直接让子类和父类成为继承关系，却不需要创建实例，这样就能够既享受到父类原型上的方法又不需要调用两次父类的构造函数和重写父类属性了。下面使用以下这个方法：

```js
function inheritPrototype(subType, superType) {
	var prototype = superType.prototype;
	prototype.constructor = subType;
	subType.prototype = prototype;
}
function Cat(name) {
	this.name = name;
	this.habit = ['sleep', 'mouse'];
}
Cat.prototype.sayHi = function() {
	console.log('miao~');
}
function YellowCat(name) {
	this.name = name;
	this.color = 'Yellow';
}
inheritPrototype(YellowCat, Cat);
let xiaohua = new YellowCat('xiaohua');
xiaohua.sayHi();
```

这种继承方式通常被认为是最理想的继承范式。

