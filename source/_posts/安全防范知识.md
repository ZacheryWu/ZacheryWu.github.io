---
title: 安全防范知识
date: 2020-04-25 10:21:36
tags:
---
安全是很复杂的一个领域，这里只选一些前端比较常见的安全问题进行总结。
## XSS
### XSS介绍

XSS是指跨站脚本攻击，是cross site scripting的缩写，攻击者通过注入，在页面上执行恶意的脚本，可以获取到用户的cookie、sessionID等用户敏感信息。为了和CSS区分，所以缩写为XSS。

XSS的本质是：恶意代码未经过滤，与网站的正常代码混合在一起，浏览器无法分辨哪些脚本是可信的，导致恶意代码被执行。而由于直接在客户端执行，恶意代码能够轻易地获取到用户的信息，或者利用这些信息冒充用户发起攻击。一般情况下，由于输入的限制，注入的恶意脚本较短，但是可以通过引入外部脚本，来完成攻击。

攻击者不仅仅可以通过UGC（User Generated Content）来完成攻击，甚至可以利用URL来进行攻击。因此，在处理输入时，以下内容都是不可信的，需要做处理：

- 来自用户的UGC信息
- 来自第三方的链接
- URL参数
- POST参数
- Referer(可能来自不可信的来源)
- Cookie(可能来自其他的子域注入)

### XSS的防范

XSS攻击有两大要素：1. 攻击者提交恶意代码 2. 浏览器执行恶意代码

针对这两大要素我们进行防范：

1. 对于攻击者提交恶意代码，我们尝试通过过滤用户输入来解决，然而攻击者也可以通过直接伪造请求来绕过前端的过滤。如果在后端数据写入之前进行过滤，攻击者就无法绕过，然而对于不确定类型的过滤可能会影响到一些正常数据，比如一些富文本的场景，用户确实需要输入`<script/>` ，所以通过阻止攻击者提交恶意代码是不可靠的。当然，在一些特定场景，比如确定用户输入的是电话号码、邮件等等时可以进行过滤。

2. 防止浏览器执行恶意代码，分为两部分：

   1. 防止HTML中出现注入
   2. 防止JavaScript执行时，出现恶意代码

   因为很多XSS注入都是在从服务端取出数据后拼接成html后，执行了恶意代码，所以为了预防这类漏洞，我们可以

   1. 纯前端渲染，将数据和代码分离。在纯前端渲染中，我们会明确的告诉浏览器设置的内容是文本还是属性，浏览器不会被欺骗，也就不会出现注入了。然而，在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。
   2. 对HTML充分转义。如果必须要拼接HTML，那么就要采用转义的方式，HTML的编码是十分复杂的，想要自己完成所有内容的转义很困难，所以一般采用成熟的转义库。

   然而还有一些XSS注入并不是HTML拼接造成的，攻击者直接在前端进行攻击。这是因为开发者不够严谨，使用了innerHTML 、ducoment.write()等方法，把不可信的数据作为了HTML插入到页面中。所以我们在开发中要尽可能的避免使用这些方法，如果需要用的这些，一定要避免在字符串中出现拼接不可信数据。常见的不可信方式有：

   1. innerHTML、document.write()
   2. Vue/React中，v-html/dangerousSetInnerHTML等等
   3. DOM中的内联监听事件，如location、onclick、onerror等等，还有a标签的href属性，JavaScript中的eval、settimeout等都有执行JavaScript代码的功能。

### 小结

整体的XSS防范是非常复杂繁琐的，不仅仅需要对数据进行转义，还需要确保没有多余和错误的转义，避免正常的输入变成乱码。

我们一般可以通过以下方式，减少漏洞：

- 利用模板引擎，开启模板引擎自带的转义功能
- 避免内联事件，如onLoad="onload({data})" ，尽量在js中采用addEventListener的方式添加事件
- 避免拼接HTML
- 对于DOM插入的操作要谨慎
- 主动检测和发现，使用XSS攻击字符串和扫描工具进行检测，寻找潜在的漏洞

## CSRF

### CSRF介绍

跨站请求伪造(Cross-Site Requeset Forgery)，在cookie中通常保存用户的登陆信息，而服务端通常通过这些信息进行身份验证，CSRF就是通过冒用被攻击者的身份，完成自己需要的攻击操作。

一次完整的CSRF攻击流程如下：

1. 小明登陆了a.com，并且保存了登录信息在cookie中
2. 小明访问了b.com
3. b.com向a.com发起请求，a.com/doSth=xxx，浏览器会携带上a.com的cookie
4. a.com的服务器收到请求后验证cookie，以小明的名义执行了doSth操作
5. 攻击完成，攻击者以小明的名义完成了doSth操作。

由于CSRF通常在第三方网站发起，被攻击的网站无法组织，所以只能通过增强自己网站对CSRF的防护能力来防范。

CSRF有这些特点：

- 发生在第三方域名
- 攻击者无法获取到用户的cookie信息，只是冒用

### CSRF防护

针对CSRF的特点，我们有以下防护策略：

- 阻止不明外域的访问
  - 同源策略
  - samesite cookie
- 提交时要求附加本域才能获取的信息
  - CSRF token
  - 双重cookie验证

下面详细说明这些防护策略:

1. 同源策略

   禁止外域发起的请求，要想判断是否是外域发起的请求可以通过请求头中的referer或origin来判断。但是有些正常的情况也不会携带referer，这就导致攻击者可以通过不携带referer完成攻击。所以这种方式相对简单，但还是有被攻击的漏洞。

2. CSRF Token

   1. 在用户打开页面的时候，服务器给这个用户生成一个token，这个token经过加密算法加密，但是token不能再放在cookie中，否则还会被攻击者利用，因此只能在后续每次加载页面的时候，给所有的a和form添加token参数。
   2. 在页面中提交请求时携带这个token，因为不是通过cookie携带的，所以攻击者无法获取到token
   3. 服务器验证Token是否正确，通过验证攻击者无法伪造的token就可以验证请求是否是安全的了。

   此方法比较复杂，但是更加有效。

3. 双重cookie验证

   使用token的方式验证比较复杂繁琐，双重cookie相比就简单很多。利用攻击者无法获取到用户cookie的特点，我们可以要求ajax请求或者表单请求中携带一个cookie中的值，然后后端验证请求中的值是否和cookie中的值一致。

   但是这种方式也有缺点，那就是在子域名之间也是拿不到cookie的，比如www.a.com的域名和a.com的域名无法共享，也就无法完成双重cookie验证。

4. samesite cookie属性

   Google起草的一份草案来改进HTTP协议，为set-cookie相应头添加Samesite属性，用这个属性来标明这个网站是个同站cookie，同站cookie只能被本站使用，无法作为第三方cookie。目前还不太成熟，具体使用可以参考[这篇文章](https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html)

### 小结

为了更好的防护CSRF攻击，最佳的方式是结合上面介绍的防御措施综合考虑，并且要结合自己的Web应用的自身情况做出决定。



## 总结

前端的安全是开发中非常重要的一部分，尤其是在开发时小心产生可能被XSS注入的漏洞，现在的开发过程中，有很多的安全问题都被框架解决了，但是也会有一些框架不能覆盖到或者暴露出来的还需要注意。对于平时使用的框架也要多去了解是怎么解决安全问题的，这样在以后遇到才不会手忙脚乱。



## 参考资料

[前端安全系列（一）：如何防止XSS攻击？](https://tech.meituan.com/2018/09/27/fe-security.html)

[前端安全系列（二）：如何防止CSRF攻击？](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)

[Cookie 的 SameSite 属性](https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html)

[前端面试之道-安全防范知识点]()

