---
title: 浏览器缓存机制
date: 2020-04-13 21:57:43
tags:
---

浏览器的缓存机制，其实都是根据HTTP请求的缓存标识来完成的，这些缓存标识都放在HTTP的请求头和响应头中。

从缓存的角度看，一次HTTP请求的过程如下：

1. 浏览器去查询缓存，如果有该请求的缓存并且有效，则直接返回，不需要发起网络请求
2. 如果不存在对应的缓存，或者缓存已经失效，则发起网络请求
3. 网络请求返回结果和缓存规则
4. 浏览器按照返回的缓存规则把返回的结果存储到浏览器缓存中

可以看到，在第一步中，根据缓存是否命中分为两种情况：

- 强缓存，根据请求头的expires和cache-control判断是否命中缓存，如果命中直接从缓存中读取资源，如果没有命中则需要向服务器发起请求。
- 协商缓存，通过Last-Modified和eTag来判断是否命中缓存，如果命中则直接从缓存中获取资源，如果没有命中，则需要从请求中获取资源。

### 强制缓存

1. cache-control

   这是个通用首部字段，既可以用在请求头里也可以用在返回头里，只是使用的指令不太相同。出现于HTTP/1.1优先级高于expires，表示相对缓存的时间，使用方式如下：

   ```js
   cache-control: max-age=30000
   ```

   cache-control作为请求头使用时，常用的指令如下:

   | 指令     | 说明                                       |
   | -------- | ------------------------------------------ |
   | no-cache | 强制向源服务器再次验证(会有资源缓存到本地) |
   | no-store | 不在本地缓存                               |
   | max-age  | 缓存有效的时间(该事件为相对值)             |

   cache-control作为响应头使用时，常用指令如下：

   | 指令     | 说明                                                        |
   | -------- | ----------------------------------------------------------- |
   | public   | 指可以被所有的用户缓存，包括客户端和中间CDN等中间代理服务器 |
   | private  | 指只能被客户端缓存，代理服务器不允许缓存                    |
   | no-cache | 缓存前必须要向服务器验证有效性                              |
   | no-store | 不允许在本地缓存                                            |
   | max-age  | 缓存有效的时间                                              |

2. expires

   这是一个返回头的实体首部字段，可以指定资源缓存失效的时间，使用方式如下:

   ```js
   Expires: Thur, 16 2020 07:20:00 GMT
   ```

   这个字段在HTTP/1.0就被加入了，因为此字段是根据客户端时间来判断的，因此会因为客户端修改时间而失效，所以在后续的HTTP版本中引入了cache-control的max-age，也因此在两者同时出现时cache-control的max-age指令的优先级更高。

## 协商缓存

在强缓存没有命中的时候，会向服务端发起请求，验证协商缓存是否命中，如果协商缓存命中，那么请求返回状态码为304，如果没有命中，则直接返回并且状态码为200。

协商缓存利用的字段是last-modify/if-modify-since 和 etag/if-none-match 这两对头部字段来管理。

1. last-modify/if-modify-since

   - last-modify，顾名思义是指资源的最后变化日期，这是一个实体头部字段
   - if-modify-since，这是一个请求头部字段，一般会携带上次这个请求返回的last-modify

   浏览器携带if-modify-since发出请求后，服务端对资源进行判断，如果在该日期之后没有更新那么表示协商缓存命中返回304状态码，否则将携带最新的资源返回，并且在last-modify中保存最后更新的时间。

   但是在本地打开资源文件，却没有修改时，也会修改last-modify返回的时间，所以出现了etag/if-none-match字段。

2. etag/if-none-match

   - etag，将资源以字符串的形式表示的唯一标识，只与资源的内容相关，和修改时间等没有关系。etag可以保证每个资源是唯一的。
   - if-none-match，在请求时将上次该请求返回的etag携带，服务端进行比对，如果相同，说明资源不变，协商缓存命中返回状态码为304，如果不同，那么资源变化，返回新的资源并生成一个新的etag值在返回头中。

## 总结

通过正确的使用缓存可以减少很多不必要的网络请求。但是如果使用不当，可能会导致资源无法正常更新，所以也就有了我们常说的，清下缓存再试试...



## 参考资料

[浏览器缓存机制](https://github.com/amandakelake/blog/issues/41)

[掘金小册-前端面试之道]()

[HTTP缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)

[图解HTTP]()











